stages:
  - image
  - build
  - test
  - test-debug
  - deploy

variables:
  GIT_DEPTH: 5
  GIT_SUBMODULE_STRATEGY: none
  # Tag to deploy builder and server images
  DEPLOY_TAG: $CI_COMMIT_REF_SLUG
  # Builder image to deploy for building
  BUILDER_IMAGE: $CI_REGISTRY/$CI_PROJECT_PATH/builder
  SKIP_BUILDER_IMAGE: "false"
  # Image with compilation cache
  BUILT_IMAGE: $CI_REGISTRY/$CI_PROJECT_PATH/built
  # Slim server image to be used in integration
  DEPLOY_IMAGE: $CI_REGISTRY/$CI_PROJECT_PATH/deploy

workflow:
  rules:
    # Main branch - deploy image as latest
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        DEPLOY_TAG: latest
    # Other branches need manual run at Gitlab
    - if: $CI_PIPELINE_SOURCE == "web"
    - if: $CI_COMMIT_BRANCH == "refactor/async"

# Template for jobs that use docker image
.docker-template: &docker-template
  image: docker:latest
  tags:
    - docker
  services:
    - docker:dind
  before_script: &docker-login
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE:$DEPLOY_TAG -f $DOCKERFILE .
    - docker push $IMAGE:$DEPLOY_TAG
  cache: []

.swift-built-template: &swift-built-template
    image: $BUILT_IMAGE:$DEPLOY_TAG
    variables:
      GIT_SUBMODULE_STRATEGY: recursive
      LOG_LEVEL: debug
    script: []

# Build image that contains the dependencies for building the server
builder-image:
  stage: image
  <<: *docker-template
  variables:
    DOCKERFILE: Dockerfile.builder
    IMAGE: $BUILDER_IMAGE
  interruptible: true
  rules:
    - if: $SKIP_BUILDER_IMAGE == "false"
      changes:
        - $DOCKERFILE
        - Package.swift
        - Package.resolved
  needs: []

# Main build job
build-release:
  stage: build
  <<: *docker-template
  variables:
    GIT_SUBMODULE_STRATEGY: recursive
    IMAGE: $BUILDER_IMAGE
    CONTAINER: planejador
  before_script:
    - *docker-login
    - docker create -i --name $CONTAINER $IMAGE:$DEPLOY_TAG
    - docker start $CONTAINER
  script:
    # prepare local source
    - docker cp Sources/ $CONTAINER:/build/Sources
    - docker cp Tests/ $CONTAINER:/build/Tests
    - docker cp .swiftlint.yml $CONTAINER:/build/
    # build swift with cache
    - docker exec -i $CONTAINER swift build -c release
    - export EXECUTABLE=$(docker exec -i $CONTAINER swift build -c release --show-bin-path)/Run
    - docker exec -i $CONTAINER $EXECUTABLE build-cache
    - docker commit $CONTAINER $BUILT_IMAGE:$DEPLOY_TAG
    - docker push $BUILT_IMAGE:$DEPLOY_TAG
    # get artifacts out of of the container
    - docker cp $CONTAINER:"$EXECUTABLE" ./Run
    - docker cp $CONTAINER:/build/Resources/ ./Resources
  artifacts:
    name: "binary-and-cache"
    paths:
      - Run
      - Resources/Cache/
    expire_in: 1 hour
  needs:
    - job: builder-image
      optional: true
      artifacts: false

# Lint source files
swift-lint:
  stage: test
  <<: *swift-built-template
  script:
    - swiftlint
  needs:
    - job: build-release
      artifacts: false

# Main test job
test-release-version:
  stage: test
  <<: *swift-built-template
  script:
    - swift test -c release
  needs:
    - job: build-release
      artifacts: false

# Test debug version if release tests fail
test-debug-version:
  stage: test-debug
  <<: *swift-built-template
  script:
    - swift build -c debug
    - swift test -c debug
  when: on_failure
  needs:
    - job: test-release-version
      optional: true
      artifacts: false

# Build server image to be used
deploy-image:
  stage: deploy
  <<: *docker-template
  variables:
    DOCKERFILE: Dockerfile
    IMAGE: $DEPLOY_IMAGE
  needs:
    - job: build-release
      artifacts: true
